names(col) <- c(names(vecColPoint),names(vecColCourbe),names(vecColHline))
## si description graphique en 3 panels
if(description) {
p <- ggplot(data = dgg, mapping = aes(x = annee, y = val))
## Titre, axes ...
p <- p + facet_grid(panel ~ ., scale = "free") +
theme(legend.position="none",
panel.grid.minor=element_blank(),
panel.grid.major.y=element_blank())  +
ylab("") + xlab("Annee")+ ggtitle(titre) +
scale_colour_manual(values=col, name = "" ,
breaks = names(col))+
scale_x_continuous(breaks=min(dgg$annee):max(dgg$annee))
p <- p + geom_hline(data =hline.data,mapping = aes(yintercept=z, colour = couleur,linetype=type ),
alpha=1,size=1.2)
if(assessIC){ ############# ONLY FOR THE CONFIDENCE INTERVAL
p <- p + geom_ribbon(mapping=aes(ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
p <- p + geom_pointrange(mapping= aes(y=val,ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
}
p <- p + geom_line(mapping=aes(colour=courbe),size = 1.5)
p <- p + geom_point(mapping=aes(colour=courbe),size = 3)
p <- p + geom_point(mapping=aes(colour=catPoint,alpha=ifelse(!is.na(catPoint),1,0)),size = 2)
p <-  p + geom_text(data=tabTextPent, mapping=aes(x,y,label=txt),parse=FALSE,color=col[vpan[1]],fontface=2, size=4)
ggsave(figname, p,width=16,height=21, units="cm")
print (figname)  ##### CAN BE REMOVED IF YOU DO NOT WANT THE GRAPH TO BE PLOTTED
} else {
p <- ggplot(data = subset(dgg,panel=="Variation abondance"), mapping = aes(x = annee, y = val))
## Titre, axes ...
p <- p + facet_grid(panel ~ ., scale = "free") +
theme(legend.position="none",
panel.grid.minor=element_blank(),
panel.grid.major.y=element_blank())  +
ylab("") + xlab("Annee")+ ggtitle(titre) +
scale_colour_manual(values=col, name = "" ,
breaks = names(col))+
scale_x_continuous(breaks=min(dgg$annee):max(dgg$annee))
p <- p + geom_hline(data =subset(hline.data,panel=="Variation abondance"),mapping = aes(yintercept=z, colour = couleur,linetype=type ),
alpha=1,size=1.2)
if(assessIC){ ############# ONLY FOR THE CONFIDENCE INTERVAL
p <- p + geom_ribbon(mapping=aes(ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
p <- p + geom_pointrange(mapping= aes(y=val,ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
}
p <- p + geom_line(mapping=aes(colour=courbe),size = 1.5)
p <- p + geom_point(mapping=aes(colour=courbe),size = 3)
p <- p + geom_point(mapping=aes(colour=catPoint,alpha=ifelse(!is.na(catPoint),1,0)),size = 2)
p <-  p + geom_text(data=tabTextPent, mapping=aes(x,y,label=txt),parse=FALSE,color=col[vpan[1]],fontface=2, size=4)
ggsave(figname, p,width=15,height=9,units="cm")
print (figname) ##### CAN BE REMOVED IF YOU DO NOT WANT THE GRAPH TO BE PLOTTED
}
}
filesaveAn <-  paste("Output/",id,"/variationsAnnuellesEspece_",id,".tabular",  ##### Nom du dossier ET fichier de sortie des resultats par annÃ©e / name of the output file with results for each years
sep = "")
filesaveTrend <-  paste("Output/",id,"/tendanceGlobalEspece_",id,".tabular",   ##### Nom du dossier ET fichier de sortie des resultats pour la pÃ©riode "annee" complete / name of the output file with the results for the period
sep = "")
fileSaveGLMs <-  paste("Output/",id,"/listGLM_",id,sep = "")  #####  Nom du dossier ET fichier de sortie des modÃ¨les lineaire generalisÃ©s / name of the output file of the generlized linear models
seuilSignif <- 0.05  ## seuil de significativite / significancy threshold
rownames(tabsp) <- tabsp$espece  ## change nom des lignes de tabsp (table de reference des especes)
##vpan vecteur des panels de la figure  ###### POUR FAIRE LES GRAPHIQUES
vpan <- c("Variation abondance")
if(description) vpan <- c(vpan,"Occurrences","Abondances brutes")
description=TRUE
id="france"
donneesAll=dataCLEAN
assessIC= TRUE
tabsp=tabsp
id<-"mainglm2"  ##### nom du dossier de sortie des resultats / name of the output folder
spExclude <- c("ALAARV") ##### liste d'espece qu on veut exclure de l analyse  / list of species that will be excluded
AssessIC <-FALSE ##########  TRUE ou FALSE rÃ©alise glm "standard" avec calcul d'intervalle de confiance ou speedglm sans IC bien plus rapide / TRUE or FALSE perform a "standard" glm with confidance interval or speedglm without CI much more fast
## creation d'un dossier pour y mettre les resultats / create folder for the output of the analyses
dir.create(paste("Output/",id,sep=""),recursive=TRUE,showWarnings=FALSE)
#cat(paste("Create Output/",id,"\n",sep=""))
dir.create(paste("Output/",id,"/Incertain/",sep=""),recursive=TRUE,showWarnings=FALSE)
#cat(paste("Create Output/",id,"Incertain/\n",sep=""))
#Import des donnÃ©es / Import data
tabCLEAN <- fread("Datafilteredfortrendanalysis.tabular",sep="\t",dec=".",header=TRUE,encoding="UTF-8") #### charge le fichier de donnÃ©es d abondance / load abundance of species
tabsp <- fread("tabSpecies.csv",sep="\t",dec=".",header=TRUE,encoding="UTF-8")   #### charge le fichier de donnees sur nom latin, vernaculaire et abbreviation, espece indicatrice ou non / load the file with information on species specialization and if species are indicators
vars_tabCLEAN<-c("carre","annee","espece","abond")
err_msg_tabCLEAN<-"The input dataset filtered doesn't have the right format. It need to have the following 4 variables :\n- carre\n- annee\n- espece\n- abond\n"
vars_tabsp<-c("espece","nom","nomscientific","indicateur","specialisation")
err_msg_tabsp<-"\nThe species dataset filtered doesn't have the right format. It need to have the following 4 variables :\n- espece\n- nom\n- nomscientific\n- indicateur\n- specialisation\n"
check_file(tabCLEAN,err_msg_tabCLEAN,vars_tabCLEAN,4)
check_file(tabsp,err_msg_tabsp,vars_tabsp,5)
firstYear <- min(tabCLEAN$annee) #### RecupÃ¨re 1ere annee des donnees / retrieve the first year of the dataset
lastYear <- max(tabCLEAN$annee)  #### RÃ©cupÃ¨re la derniÃ¨re annee des donnees / retrieve the last year of the dataset
annees <- firstYear:lastYear  ##### !!!! une autre variable s'appelle annee donc peut Ãªtre Ã  modif en "periode" ? ### argument de la fonction mais  DECLARER DANS LA FONCTION AUSSI donc un des 2 Ã  supprimer
spsFiltre=unique(tabCLEAN$espece) #### RecupÃ¨re la liste des especes du tabCLEAN qui ont Ã©tÃ© sÃ©lectionnÃ©e et qui ont passÃ© le filtre / retrieve species name that were selected and then filtered before
#cat("\n\nspsFiltre\n")
tabsp=subset (tabsp, (espece %in% spsFiltre)) #### liste des espÃ¨ces exclu par le filtre ou manuellement / List of species excluded manually or by the filter from the analyses
#cat("\n\ntabsp\n")
sp=as.character(tabsp$espece)  ##### liste des espece en code ou abbreviation gardÃ©es pour les analyses ### arg de la fonction  DECLARE AUSSI APRES DS FONCTION  / list of the code or abbreviation of the species kept for the analyses
#cat("\n\nsp\n")
if(length(spExclude)!=0) {
tabCLEAN <- subset(tabCLEAN,!(espece %in% spExclude))
tabsp <- subset(tabsp, !(espece %in% spExclude))
cat("\n\nEspÃ¨ces exclues de l'analyse :\n")
cat(spExclude)
cat("\n")
}
if(length(tabCLEAN$espece)==0){
stop("There is no species left for the analyse.", call.=FALSE) #si pas plus d'espÃ¨ce aprÃ¨s filtre / if no more species after filter
}
#cat("\n\ntabsp\n")
id
id
donneesAll=dataCLEAN
assessIC= TRUE
setwd("C:/Users/royau/OneDrive/Documents/stage M2/Outils STOC")
####### fonctions #####
check_file<-function(dataset,err_msg,vars,nb_vars){
if(ncol(dataset)!=nb_vars){ #Verifiction de la prÃ©sence du bon nb de colonnes, si c'est pas le cas= message d'erreur / checking for right number of columns in the file if not = error message
cat("\nerr nb var\n")
stop(err_msg, call.=FALSE)
}
for(i in vars){
if(!(i %in% names(dataset))){
stop(err_msg,call.=FALSE)
}
}
}
affectCatEBCC <- function(trend,pVal,ICinf,ICsup){
catEBCC <- ifelse(pVal>0.05,
ifelse(ICinf < 0.95 | ICsup > 1.05,"Incertain","Stable"),
ifelse(trend<1,
ifelse(ICsup<0.95,"Fort declin","Declin moderee"),
ifelse(ICinf>1.05,"Forte augmentation","Augmentation modere")))
return(catEBCC)
}
ggplot.espece <- function(dgg,tab1t,id,serie=NULL,sp,valide,nomSp=NULL,description=TRUE,
tendanceSurFigure=TRUE,seuilOccu=14, vpan,assessIC=TRUE) {
#  serie=NULL;nomSp=NULL;description=TRUE;valide=catIncert
#  tendanceSurFigure=TRUE;seuilOccu=14
require(ggplot2)
figname<- paste("Output/",id,"/",ifelse(valide=="Incertain","Incertain/",""),
sp,"_",id,serie, ".png",
sep = "")
## coordonnee des ligne horizontal de seuil pour les abondances et les occurences
hline.data1 <- data.frame(z = c(1), panel = c(vpan[1]),couleur = "variation abondance",type="variation abondance")
hline.data2 <- data.frame(z = c(0,seuilOccu), panel = c(vpan[2],vpan[2]),couleur = "seuil",type="seuil")
hline.data3 <- data.frame(z = 0, panel = vpan[3] ,couleur = "seuil",type="seuil")
hline.data <- rbind(hline.data1,hline.data2,hline.data3)
titre <- paste(nomSp)#,"\n",min(annee)," - ",max(annee),sep="")
## texte de la tendance / text for the population evolution trend
tab1 <- subset(dgg,panel =="Variation abondance")
pasdetemps <- max(dgg$annee) - min(dgg$annee) + 1
if(assessIC){
txtPente1 <- paste(tab1t$Est,
ifelse(tab1t$signif," *",""),"  [",tab1t$LL," , ",tab1t$UL,"]",
ifelse(tab1t$signif,paste("\n",ifelse(tab1t$pourcent>0,"+ ","- "),
abs(tab1t$pourcent)," % en ",pasdetemps," ans",sep=""),""),sep="")
}else{
txtPente1 <- ifelse(tab1t$signif,paste("\n",ifelse(tab1t$pourcent>0,"+ ","- "),
abs(tab1t$pourcent)," % en ",pasdetemps," ans",sep=""),"")
}
## table du texte de la tendance / table of the text for the population evolution trend
tabTextPent <- data.frame(y=c(max(c(tab1$val,tab1$UL),na.rm=TRUE)*.9),
x=median(tab1$annee),
txt=ifelse(tendanceSurFigure,c(txtPente1),""),
courbe=c(vpan[1]),panel=c(vpan[1]))
## les couleurs / the colors
vecColPoint <- c("#ffffff","#eeb40f","#ee0f59")
names(vecColPoint) <- c("significatif","infSeuil","0")
vecColCourbe <- c("#3c47e0","#5b754d","#55bb1d","#973ce0")
names(vecColCourbe) <- c(vpan[1],"carre","presence",vpan[3])
vecColHline <- c("#ffffff","#e76060")
names(vecColHline) <- c("variation abondance","seuil")
col <- c(vecColPoint,vecColCourbe,vecColHline)
names(col) <- c(names(vecColPoint),names(vecColCourbe),names(vecColHline))
## si description graphique en 3 panels
if(description) {
p <- ggplot(data = dgg, mapping = aes(x = annee, y = val))
## Titre, axes ...
p <- p + facet_grid(panel ~ ., scale = "free") +
theme(legend.position="none",
panel.grid.minor=element_blank(),
panel.grid.major.y=element_blank())  +
ylab("") + xlab("Annee")+ ggtitle(titre) +
scale_colour_manual(values=col, name = "" ,
breaks = names(col))+
scale_x_continuous(breaks=min(dgg$annee):max(dgg$annee))
p <- p + geom_hline(data =hline.data,mapping = aes(yintercept=z, colour = couleur,linetype=type ),
alpha=1,size=1.2)
if(assessIC){ ############# ONLY FOR THE CONFIDENCE INTERVAL
p <- p + geom_ribbon(mapping=aes(ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
p <- p + geom_pointrange(mapping= aes(y=val,ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
}
p <- p + geom_line(mapping=aes(colour=courbe),size = 1.5)
p <- p + geom_point(mapping=aes(colour=courbe),size = 3)
p <- p + geom_point(mapping=aes(colour=catPoint,alpha=ifelse(!is.na(catPoint),1,0)),size = 2)
p <-  p + geom_text(data=tabTextPent, mapping=aes(x,y,label=txt),parse=FALSE,color=col[vpan[1]],fontface=2, size=4)
ggsave(figname, p,width=16,height=21, units="cm")
print (figname)  ##### CAN BE REMOVED IF YOU DO NOT WANT THE GRAPH TO BE PLOTTED
} else {
p <- ggplot(data = subset(dgg,panel=="Variation abondance"), mapping = aes(x = annee, y = val))
## Titre, axes ...
p <- p + facet_grid(panel ~ ., scale = "free") +
theme(legend.position="none",
panel.grid.minor=element_blank(),
panel.grid.major.y=element_blank())  +
ylab("") + xlab("Annee")+ ggtitle(titre) +
scale_colour_manual(values=col, name = "" ,
breaks = names(col))+
scale_x_continuous(breaks=min(dgg$annee):max(dgg$annee))
p <- p + geom_hline(data =subset(hline.data,panel=="Variation abondance"),mapping = aes(yintercept=z, colour = couleur,linetype=type ),
alpha=1,size=1.2)
if(assessIC){ ############# ONLY FOR THE CONFIDENCE INTERVAL
p <- p + geom_ribbon(mapping=aes(ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
p <- p + geom_pointrange(mapping= aes(y=val,ymin=LL,ymax=UL),fill=col[vpan[1]],alpha=.2)
}
p <- p + geom_line(mapping=aes(colour=courbe),size = 1.5)
p <- p + geom_point(mapping=aes(colour=courbe),size = 3)
p <- p + geom_point(mapping=aes(colour=catPoint,alpha=ifelse(!is.na(catPoint),1,0)),size = 2)
p <-  p + geom_text(data=tabTextPent, mapping=aes(x,y,label=txt),parse=FALSE,color=col[vpan[1]],fontface=2, size=4)
ggsave(figname, p,width=15,height=9,units="cm")
print (figname) ##### CAN BE REMOVED IF YOU DO NOT WANT THE GRAPH TO BE PLOTTED
}
}
main.glm <- function(id="france",donneesAll=dataCLEAN,assessIC= TRUE,tabsp=tabsp,annees=annees,figure=TRUE,description=TRUE,tendanceSurFigure=TRUE, ###### declaration des arguments  listSp=sp Ã©tait avant declarÃ© avant la fonction mais il me semble que ca marche aussi comme cela
seuilOccu=14,seuilAbond=NA) {
filesaveAn <-  paste("Output/",id,"/variationsAnnuellesEspece_",id,".tabular",  ##### Nom du dossier ET fichier de sortie des resultats par annÃ©e / name of the output file with results for each years
sep = "")
filesaveTrend <-  paste("Output/",id,"/tendanceGlobalEspece_",id,".tabular",   ##### Nom du dossier ET fichier de sortie des resultats pour la pÃ©riode "annee" complete / name of the output file with the results for the period
sep = "")
fileSaveGLMs <-  paste("Output/",id,"/listGLM_",id,sep = "")  #####  Nom du dossier ET fichier de sortie des modÃ¨les lineaire generalisÃ©s / name of the output file of the generlized linear models
seuilSignif <- 0.05  ## seuil de significativite / significancy threshold
rownames(tabsp) <- tabsp$espece  ## change nom des lignes de tabsp (table de reference des especes)
##vpan vecteur des panels de la figure  ###### POUR FAIRE LES GRAPHIQUES
vpan <- c("Variation abondance")
if(description) vpan <- c(vpan,"Occurrences","Abondances brutes")
## specifications des variables temporelles necesaires pour les analyses / specification of temporal variable necessary for the analyses
annee <- sort(unique(donneesAll$annee))
nbans <- length(annee)
pasdetemps <- nbans-1
firstY <- min(annee)
lastY <- max(annee)
## Ordre de traitement des especes ### order of species to be analyzed
spOrdre <- aggregate(abond~espece,data=donneesAll,sum)  #### calcul les sommes des abondances pour ordonner / calculate the sum for the ordination
spOrdre <- merge(spOrdre,tabsp,by="espece") #### rajoute la colonne avec les abondances totales par espece / add a new column with the sum
spOrdre <- spOrdre[order(as.numeric(spOrdre$indicateur),spOrdre$abond,decreasing = TRUE),] #### mets les especes plus abondantes en premiers (plus long pour faire tourner le modÃ¨le) / order the species by abundance, the most abundant species being the less fast analysis
listSp <- spOrdre$espece
i <- 0
nbSp <- length(listSp)
#	browser()
## analyse par espece
### browser()
## affichage des especes conservees pour l'analyse  ### PAS SUR QUE CE SOIT ENCORE UTILE
cat("\n",nbSp," EspÃ¨ces conservÃ©es pour l'analyse\n\n",sep="")
rownames(tabsp) <- tabsp$espece
print(tabsp[,1:2])
#tabCons <- data.frame(Code_espece = listSp, nom_espece = tabsp[as.character(listSp),"nom"])
#print(tabCons)
cat("\n\n",sep="")
flush.console()
## initialisation de la liste de sauvegarde
##browser()
for (sp in listSp) {  ######## Boucle pour analyse par espÃ¨ce / loop for the analysis by species
i <- i + 1
d <- subset(donneesAll,espece==sp)  ## d data pour l'espece en court  / cut the data keeping only the i species
#nomSp <- as.character(tabsp[sp,"nom"])  ## info sp
nomSp <- tabsp$nom[which(tabsp$espece==sp)]  ## info sp
cat("\n(",i,"/",nbSp,") ",sp," | ", nomSp,"\n",sep="")
flush.console()
#indic <- tabsp[sp,"indicateur"] ## indic :espece utilisee pour le calcul des indicateurs par groupe de specialisation / list the species used as species indicators by trophic specialization
indic <- tabsp$indicateur[which(tabsp$espece==sp)] ## indic :espece utilisee pour le calcul des indicateurs par groupe de specialisation / list the species used as species indicators by trophic specialization
nb_carre = tapply(rep(1,nrow(d)),d$annee,sum) ## nb_carre nombre de carre suivie par annee / number of plots per year
nb_carre_presence = tapply(ifelse(d$abond>0,1,0),d$annee,sum) ## nb_carre_presence nombre de carre de presence par annee / number the plots where the species were observed
tab2 <- data.frame(annee=rep(annee,2),val=c(nb_carre,nb_carre_presence),LL = NA,UL=NA, ## tab2 table de resultat d'analyse / data.frame of the analyses results
catPoint=NA,pval=NA,
courbe=rep(c("carre","presence"),each=length(annee)),panel=vpan[2])
tab2$catPoint <- ifelse(tab2$val == 0,"0",ifelse(tab2$val < seuilOccu,"infSeuil",NA))
abond <- tapply(d$abond,d$annee,sum) ## abond abondance par annee / abundance per year
tab3 <- data.frame(annee=annee,val=abond,LL = NA,UL=NA,catPoint=NA,pval=NA,courbe=vpan[3],panel=vpan[3]) ## table pour la figure / data.frame made to realize the graphical outputs
tab3$catPoint <- ifelse(tab3$val == 0,"0",ifelse(tab3$val < seuilAbond,"infSeuil",NA))
## GLM pour calcul des tendances annuelles de l'evolution des populations / GLM to measure annual tendency of population evolution
formule <- as.formula("abond~as.factor(carre)+as.factor(annee)") #### specification du modÃ¨le = log lineaire / specifying the model = log linear
if(assessIC) {##### OPTION A RENTRER AU DEBUT PEUT ÃTRE A METTRE DANS LES ARGUMENTS SI LAISSE LE CHOIX SINON L ARG PAR DEFAUT LORS DE LA DECLARATION DE LA FONCTION
glm1 <- glm(formule,data=d,family=quasipoisson)  ##### fit model lineaire general avec intervalle de confiance disponible / fit linear and generalized model with confidence intervalle available
} else {
glm1 <- try(speedglm(formule,data=d,family=quasipoisson())) ##### fit modele lineaire et generaux pour les gros jeux de donnÃ©es / fit of linear and generalized model for large-medium dataset
if(class(glm1)[1]=="try-error")
glm1 <- glm(formule,data=d,family=quasipoisson) ##### comprends pas mais je pense que c'est speedglm qui marche pas avec toutes les donnÃ©es
}
sglm1 <- summary(glm1)  #### sortie du modele / output of the model
sglm1 <- coefficients(sglm1) ### coefficient regression de chaque variable avec les rÃ©sultats des tests statistiques / regression coefficient of each predictive variables with results of the statistical tests
sglm1 <- tail(sglm1,pasdetemps) #### recupÃ©re les derniers elements du modÃ¨le avec la taille de l'objet "pasdetemps" car le nombre de coef = nbre d'annÃ©e et pas les coefficient de regression de la variable carre / retrieve only the coefficient regression of the variable year
coefan <- as.numeric(as.character(sglm1[,1]))#### coefficient de regression de la variable annÃ©e (1 pour chaque annÃ©e)
coefannee <- c(1,exp(coefan))## coefannee vecteur des variation d'abondance par annee avec transformation inverse du log :exp() / regression coefficient of the year back transformed from log(abundance) : exp()
erreuran <- as.numeric(as.character(sglm1[,2])) #### erreur standard sur le coefficient de regression de la variable annee  / standard error on the regression coefficient of the year
erreurannee1 <- c(0,erreuran*exp(coefan))## erreur standard par annÃ©e / the standard error per year  ###### LA J AI UN DOUTE NORMALEMENT INTERVAL DE CONF C CI_lower <- coefficients(lin_mod)[2] - 1.96*summary(lin_mod)$coefficients[2,2]
####CI_upper <- coefficients(lin_mod)[2] + 1.96*summary(lin_mod)$coefficients[2,2]
pval <- c(1,as.numeric(as.character(sglm1[,4])))###### p value
## calcul des intervalle de confiance avec methode de bootstrap pour simuler des coef de regress sur lequel intervalle de conf sont mesurÃ©s/ calcul of the confidence interval using bootstrap method to simulate set regression coefficients and s.e.with uncertainty   POURQUOI PAS UTILISE confint.glm() ou boot() ou ci.boot()
if(assessIC) {
glm1.sim <- sim(glm1)
ic_inf_sim <- c(1,exp(tail(apply(coef(glm1.sim), 2, quantile,.025),pasdetemps)))
ic_sup_sim <- c(1,exp(tail(apply(coef(glm1.sim), 2, quantile,.975),pasdetemps)))
} else {
ic_inf_sim <- NA
ic_sup_sim <- NA
}
tab1 <- data.frame(annee,val=coefannee,  ## tab1 table pour la realisation des figures / table for the graphical outputs  ### 2EME POUR GRAPH ici ce sont le coef de regress annee en fonction des annÃ©Ã©s alors que tab3 c'est les abondance en fct des annÃ©es et tab2 nombre de carrÃ© total et avec presence
LL=ic_inf_sim,UL=ic_sup_sim,
catPoint=ifelse(pval<seuilSignif,"significatif",NA),pval,
courbe=vpan[1],
panel=vpan[1])
## netoyage des intervalle de confiance mal estimÃ©s et qd donnees pas suffisantes pour calcul d'IC /cleaning of wrong or biaised measures of the confidence interval
if(assessIC) {
tab1$UL <- ifelse( nb_carre_presence==0,NA,tab1$UL)
tab1$UL <-  ifelse(tab1$UL == Inf, NA,tab1$UL)
tab1$UL <-  ifelse(tab1$UL > 1.000000e+20, NA,tab1$UL)
tab1$UL[1] <- 1
tab1$val <-  ifelse(tab1$val > 1.000000e+20,1.000000e+20,tab1$val)
}
## indice de surdispersion  / overdispersion index
## browser()
if(assessIC) dispAn <- glm1$deviance/glm1$null.deviance else dispAn <- glm1$deviance/glm1$nulldev
## tabAn table de sauvegarde des resultats par annÃ©e / table of the results per year ######  reprends bcp de tabl DIFFERENCE AVEC tab2  c les abondances relatives, alors que nb de carre, nb de carre presnce, p val sont aussi ds tab2
tabAn <- data.frame(id,code_espece=sp, nom_espece = nomSp,indicateur = indic,annee = tab1$annee,
abondance_relative=round(tab1$val,3),
IC_inferieur = round(tab1$LL,3), IC_superieur = round(tab1$UL,3),
erreur_standard = round(erreurannee1,4),
p_value = round(tab1$pval,3),significatif = !is.na(tab1$catPoint),
nb_carre,nb_carre_presence,abondance=abond)
## GLM pour calcul des tendance generale sur la periode avec modele log lineaire / GLM to measure the tendency of population evolution on the studied period with log linear model
formule <- as.formula(paste("abond~ as.factor(carre) + annee",sep="")) ###
#  browser()
if(assessIC) {
md2 <- glm(formule,data=d,family=quasipoisson) }
else {
md2 <- try(speedglm(formule,data=d,family=quasipoisson()),silent=TRUE)
if(class(md2)[1]=="try-error")
md2 <- glm(formule,data=d,family=quasipoisson)
}
smd2 <- summary(md2)       #### sortie du modele / output of the model
smd2 <- coefficients(smd2) ### coefficient regression de chaque variable avec les rÃ©sultats des tests statistiques / regression coefficient of each predictive variables with results of the statistical tests
smd2 <- tail(smd2,1)       ### coefficient regression de variable annee avec les rÃ©sultats des tests statistiques / regression coefficient of the variable year with results of the statistical tests
coefan <- as.numeric(as.character(smd2[,1])) ## tendences sur la periode = coefficient regression de variable annee  / tendency of population evolution on the studied period = regression coefficient of the variable year
trend <- round(exp(coefan),3)
pourcentage <- round((exp(coefan*pasdetemps)-1)*100,2) ## pourcentage de variation sur la periode / percentage of population variation on the studied period
pval <- as.numeric(as.character(smd2[,4]))
erreuran <- as.numeric(as.character(smd2[,2])) #### rÃ©cuperer l'erreur standard / retrieve the error
## erreur standard
erreurannee2 <- erreuran*exp(coefan)
## calcul des intervalle de confiance avec methode de bootstrap pour simuler des coef de regress sur lequel intervalle de conf sont mesurÃ©s/ calculating the confidence interval based on bootstrap method to simulate set regression coefficients and s.e.with uncertainty
LL <- NA
UL <- NA
if(assessIC) {
md2.sim <- sim(md2)
LL <- round(exp(tail(apply(coef(md2.sim), 2, quantile,.025),1)),3)
UL <- round(exp(tail(apply(coef(md2.sim), 2, quantile,.975),1)),3)
} else {
LL <- NA
UL <- NA
}
## tab1t table utile pour la realisation des figures  / table used for the figures
tab1t <- data.frame(Est=trend,
LL , UL,
pourcent=pourcentage,signif=pval<seuilSignif,pval)
trendsignif <- tab1t$signif
pourcent <- round((exp(coefan*pasdetemps)-1)*100,3)
## mesure de la surdispersion / overdispersion measurment
if(assessIC) dispTrend <- md2$deviance/md2$null.deviance else dispTrend <- md2$deviance/md2$nulldev
## classement en categorie incertain /classifying wrong or not reliable results
# browser()
if(assessIC) {
if(dispTrend > 2 | dispAn > 2 | median( nb_carre_presence)<seuilOccu) catIncert <- "Incertain" else catIncert <-"bon"  ##### en fonction de l'indice de surdispersion et presence < Ã  seuil occurence / based on the overdispersion index and the presence on a minimum number of plots
vecLib <-  NULL
if(dispTrend > 2 | dispAn > 2 | median( nb_carre_presence)<seuilOccu) {
if(median( nb_carre_presence)<seuilOccu) {
vecLib <- c(vecLib,"espece trop rare")
}
if(dispTrend > 2 | dispAn > 2) {
vecLib <- c(vecLib,"deviance")
}
}
raisonIncert <-  paste(vecLib,collapse=" et ")
} else {
catIncert <- NA
raisonIncert <- NA
}
## affectation des tendence EBCC  / retrieve the trend of population evolution on the studied period
catEBCC <- NA
if(assessIC)  catEBCC <- affectCatEBCC(trend = as.vector(trend),pVal = pval,ICinf=as.vector(LL),ICsup=as.vector(UL)) else catEBCC <- NA
## table complete de resultats  pour la periode etudiÃ©e / complete table with results for the studied period
#   browser()
tabTrend <- data.frame(
id,code_espece=sp,nom_espece = nomSp,indicateur = indic,
nombre_annees = pasdetemps,premiere_annee = firstY,derniere_annee = lastY,
tendance = as.vector(trend) ,  IC_inferieur=as.vector(LL) , IC_superieur = as.vector(UL),pourcentage_variation=as.vector(pourcent),
erreur_standard = as.vector(round(erreurannee2,4)), p_value = round(pval,3),
significatif = trendsignif,categorie_tendance_EBCC=catEBCC,mediane_occurrence=median( nb_carre_presence) ,
valide = catIncert,raison_incertitude = raisonIncert)
if(assessIC)  listGLMsp <- list(list(glm1,glm1.sim,md2,md2.sim)) else  listGLMsp <- list(list(glm1,md2))
names(listGLMsp)[[1]] <-sp
if(sp==listSp[1]) {
glmAn <- tabAn
glmTrend <- tabTrend
} else  {
glmAn <- rbind(glmAn,tabAn)
glmTrend <- rbind(glmTrend,tabTrend)
}
## les figures
if(figure) {
## table complete pour la figure en panel par ggplot2
## table pour graphe en panel par ggplot2
if(description)	dgg <- rbind(tab1,tab2,tab3) else dgg <- tab1
## les figures
ggplot.espece(dgg,tab1t,id,serie=NULL,sp,valide=catIncert,nomSp,description,tendanceSurFigure,seuilOccu=14,vpan = vpan,assessIC=assessIC)
}
}
write.table(glmAn,filesaveAn,row.names=FALSE,quote=FALSE,sep="\t",dec=".",fileEncoding="UTF-8")
cat("--->",filesaveAn,"\n")
write.table(glmTrend,filesaveTrend,row.names=FALSE,quote=FALSE,sep="\t",dec=".",fileEncoding="UTF-8")
cat("--->",filesaveTrend,"\n")
flush.console()
}
######################################################################################################################################
############## COMMAND LINE TO CALCULATE AND PLOT EVOLUTION OF SPECIES POPULATION  function:main.glm    ##############################
######################################################################################################################################
#### Based on Romain LorrilliÃ¨re R script
#### Modified by Alan Amosse and Benjamin Yguel for integrating within Galaxy-E
#suppressMessages(library(lme4))
suppressMessages(library(ggplot2))
suppressMessages(library(speedglm))
suppressMessages(library(arm))
#suppressMessages(library(reshape))
suppressMessages(library(data.table))
suppressMessages(library(reshape2))
#####TEST 1######
#delcaration des arguments et variables/ declaring some variables and load arguments
id<-"mainglm1"  ##### nom du dossier de sortie des resultats / name of the output folder
spExclude <- c("") ##### liste d'espece qu on veut exclure de l analyse  / list of species that will be excluded
AssessIC <-TRUE ##########  TRUE ou FALSE rÃ©alise glm "standard" avec calcul d'intervalle de confiance ou speedglm sans IC bien plus rapide / TRUE or FALSE perform a "standard" glm with confidance interval or speedglm without CI much more fast
## creation d'un dossier pour y mettre les resultats / create folder for the output of the analyses
dir.create(paste("Output/",id,sep=""),recursive=TRUE,showWarnings=FALSE)
#cat(paste("Create Output/",id,"\n",sep=""))
dir.create(paste("Output/",id,"/Incertain/",sep=""),recursive=TRUE,showWarnings=FALSE)
#cat(paste("Create Output/",id,"Incertain/\n",sep=""))
#Import des donnÃ©es / Import data
tabCLEAN <- fread("Datafilteredfortrendanalysis.tabular",sep="\t",dec=".",header=TRUE,encoding="UTF-8") #### charge le fichier de donnÃ©es d abondance / load abundance of species
tabsp <- fread("tabSpecies.csv",sep="\t",dec=".",header=TRUE,encoding="UTF-8")   #### charge le fichier de donnees sur nom latin, vernaculaire et abbreviation, espece indicatrice ou non / load the file with information on species specialization and if species are indicators
vars_tabCLEAN<-c("carre","annee","espece","abond")
err_msg_tabCLEAN<-"The input dataset filtered doesn't have the right format. It need to have the following 4 variables :\n- carre\n- annee\n- espece\n- abond\n"
vars_tabsp<-c("espece","nom","nomscientific","indicateur","specialisation")
err_msg_tabsp<-"\nThe species dataset filtered doesn't have the right format. It need to have the following 4 variables :\n- espece\n- nom\n- nomscientific\n- indicateur\n- specialisation\n"
check_file(tabCLEAN,err_msg_tabCLEAN,vars_tabCLEAN,4)
check_file(tabsp,err_msg_tabsp,vars_tabsp,5)
firstYear <- min(tabCLEAN$annee) #### RecupÃ¨re 1ere annee des donnees / retrieve the first year of the dataset
lastYear <- max(tabCLEAN$annee)  #### RÃ©cupÃ¨re la derniÃ¨re annee des donnees / retrieve the last year of the dataset
annees <- firstYear:lastYear  ##### !!!! une autre variable s'appelle annee donc peut Ãªtre Ã  modif en "periode" ? ### argument de la fonction mais  DECLARER DANS LA FONCTION AUSSI donc un des 2 Ã  supprimer
spsFiltre=unique(tabCLEAN$espece) #### RecupÃ¨re la liste des especes du tabCLEAN qui ont Ã©tÃ© sÃ©lectionnÃ©e et qui ont passÃ© le filtre / retrieve species name that were selected and then filtered before
#cat("\n\nspsFiltre\n")
tabsp=subset (tabsp, (espece %in% spsFiltre)) #### liste des espÃ¨ces exclu par le filtre ou manuellement / List of species excluded manually or by the filter from the analyses
#cat("\n\ntabsp\n")
sp=as.character(tabsp$espece)  ##### liste des espece en code ou abbreviation gardÃ©es pour les analyses ### arg de la fonction  DECLARE AUSSI APRES DS FONCTION  / list of the code or abbreviation of the species kept for the analyses
#cat("\n\nsp\n")
if(length(spExclude)!=0) {
tabCLEAN <- subset(tabCLEAN,!(espece %in% spExclude))
tabsp <- subset(tabsp, !(espece %in% spExclude))
cat("\n\nEspÃ¨ces exclues de l'analyse :\n")
cat(spExclude)
cat("\n")
}
if(length(tabCLEAN$espece)==0){
stop("There is no species left for the analyse.", call.=FALSE) #si pas plus d'espÃ¨ce aprÃ¨s filtre / if no more species after filter
}
#cat("\n\ntabsp\n")
###  Do your analysis
main.glm(donneesAll=tabCLEAN,tabsp=tabsp,id=id,assessIC=AssessIC)
#####TEST 2######
#delcaration des arguments et variables/ declaring some variables and load arguments
id<-"mainglm2"  ##### nom du dossier de sortie des resultats / name of the output folder
spExclude <- c("ALAARV") ##### liste d'espece qu on veut exclure de l analyse  / list of species that will be excluded
AssessIC <-FALSE ##########  TRUE ou FALSE rÃ©alise glm "standard" avec calcul d'intervalle de confiance ou speedglm sans IC bien plus rapide / TRUE or FALSE perform a "standard" glm with confidance interval or speedglm without CI much more fast
## creation d'un dossier pour y mettre les resultats / create folder for the output of the analyses
dir.create(paste("Output/",id,sep=""),recursive=TRUE,showWarnings=FALSE)
#cat(paste("Create Output/",id,"\n",sep=""))
dir.create(paste("Output/",id,"/Incertain/",sep=""),recursive=TRUE,showWarnings=FALSE)
#cat(paste("Create Output/",id,"Incertain/\n",sep=""))
#Import des donnÃ©es / Import data
tabCLEAN <- fread("Datafilteredfortrendanalysis.tabular",sep="\t",dec=".",header=TRUE,encoding="UTF-8") #### charge le fichier de donnÃ©es d abondance / load abundance of species
tabsp <- fread("tabSpecies.csv",sep="\t",dec=".",header=TRUE,encoding="UTF-8")   #### charge le fichier de donnees sur nom latin, vernaculaire et abbreviation, espece indicatrice ou non / load the file with information on species specialization and if species are indicators
vars_tabCLEAN<-c("carre","annee","espece","abond")
err_msg_tabCLEAN<-"The input dataset filtered doesn't have the right format. It need to have the following 4 variables :\n- carre\n- annee\n- espece\n- abond\n"
vars_tabsp<-c("espece","nom","nomscientific","indicateur","specialisation")
err_msg_tabsp<-"\nThe species dataset filtered doesn't have the right format. It need to have the following 4 variables :\n- espece\n- nom\n- nomscientific\n- indicateur\n- specialisation\n"
check_file(tabCLEAN,err_msg_tabCLEAN,vars_tabCLEAN,4)
check_file(tabsp,err_msg_tabsp,vars_tabsp,5)
firstYear <- min(tabCLEAN$annee) #### RecupÃ¨re 1ere annee des donnees / retrieve the first year of the dataset
lastYear <- max(tabCLEAN$annee)  #### RÃ©cupÃ¨re la derniÃ¨re annee des donnees / retrieve the last year of the dataset
annees <- firstYear:lastYear  ##### !!!! une autre variable s'appelle annee donc peut Ãªtre Ã  modif en "periode" ? ### argument de la fonction mais  DECLARER DANS LA FONCTION AUSSI donc un des 2 Ã  supprimer
spsFiltre=unique(tabCLEAN$espece) #### RecupÃ¨re la liste des especes du tabCLEAN qui ont Ã©tÃ© sÃ©lectionnÃ©e et qui ont passÃ© le filtre / retrieve species name that were selected and then filtered before
#cat("\n\nspsFiltre\n")
tabsp=subset (tabsp, (espece %in% spsFiltre)) #### liste des espÃ¨ces exclu par le filtre ou manuellement / List of species excluded manually or by the filter from the analyses
#cat("\n\ntabsp\n")
sp=as.character(tabsp$espece)  ##### liste des espece en code ou abbreviation gardÃ©es pour les analyses ### arg de la fonction  DECLARE AUSSI APRES DS FONCTION  / list of the code or abbreviation of the species kept for the analyses
#cat("\n\nsp\n")
if(length(spExclude)!=0) {
tabCLEAN <- subset(tabCLEAN,!(espece %in% spExclude))
tabsp <- subset(tabsp, !(espece %in% spExclude))
cat("\n\nEspÃ¨ces exclues de l'analyse :\n")
cat(spExclude)
cat("\n")
}
if(length(tabCLEAN$espece)==0){
stop("There is no species left for the analyse.", call.=FALSE) #si pas plus d'espÃ¨ce aprÃ¨s filtre / if no more species after filter
}
#cat("\n\ntabsp\n")
###  Do your analysis
main.glm(donneesAll=tabCLEAN,tabsp=tabsp,id=id,assessIC=AssessIC)
setwd("D:/Documents/GitHub/tools-ecology/tools/stoc")
spTrait=read.table('species_indicateur_fonctionnel.tabular',sep="\t",dec=".",header=TRUE) ############# species_indicateur_fonctionnel.csv pour le STOC sinon fichier avec traits pour calcul du trait moyen par communautÃ© / file with the trait for the community weighted mean calculation
View(spTrait)
